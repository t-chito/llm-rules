# Ruby on Rails 特有のコードレビューガイドライン

## 1. はじめに

### 1.1 Rails特有のコードレビューの基本原則

*   **RubyおよびRailsの一般的な観点を持つ:** Rails観点のコードレビューを行う際は「Rubyリファレンスマニュアル」や「Ruby on Rails Guides」の知識を基に以下のガイドラインに記載されていない観点で気になる点やより良い言語やフレームワーク固有の機能があれば指摘したり提案しても良いです。
*   **「好み」と「良し悪し」を区別する:** フィードバックが客観的な改善提案（良し悪し）なのか、主観的な好みなのかを明確にし、理由を説明します。

## 2. 設計 (Design)

### 2.1 責務と凝集度・結合度

*   **単一責任の原則 (SRP):** クラスやメソッドは、一つの明確な責務（役割）を持つべきです。複数の無関係な処理を一つの単位で行わないようにします。
    *   例: `set_book` メソッドがインスタンス設定だけでなく、関連データの作成・保存まで行うのは責務過多。
*   **ロジックの適切な配置:** ビジネスロジックやデータ操作ロジックが、適切なクラス（Controller, Model, Service Object, Form Object, Helperなど）に配置されているか確認します。
    *   例: コントローラーがデータ操作の詳細（複数レコードの初期化・保存など）を持つのではなく、モデルのクラスメソッドなどに委譲する。

### 2.2 シンプルさとYAGNI

*   **YAGNI (You Ain't Gonna Need It):** 現時点で必要ない機能や汎用化（オーバーエンジニアリング）は実装しません。将来の問題は、実際に発生してから対処します。

### 2.3 API設計とインターフェース

*   **RESTfulな設計:** Web APIなどは、リソース指向に基づいたRESTfulな設計原則に従っているか確認します。URL設計（パス）、HTTPメソッドの選択が適切か。
    *   例: 独自ルーティングではなく `resources` を活用し、必要に応じてネストする。

### 2.4 フレームワーク・ライブラリの利用

*   **Rails Wayへの準拠:** Railsプロジェクトの場合、フレームワークの標準的な慣習（Rails Way）に沿っているか確認します。（経験則）

## 3. コード品質 (Code Quality)

### 3.1 命名 (Naming)

*   **規約への準拠:** 言語やフレームワークの命名規約に従っているか。
    *   例: 真偽値を返すメソッドは `?` で終わる、破壊的メソッドは `!` で終わる。
    *   例: boolean型のカラム名は `is_` や `has_` ではなく、`true`が表す状態（形容詞や受動態）を示す名前（`approved`, `active`）にする。
*   **副作用の明示:** 副作用のあるメソッドには動詞を、ないメソッドには名詞を使うなど、メソッドの性質を名前に反映させる。

### 3.2 コメント (Comments)

*   **「なぜ」を説明する:** コメントは、コードが**何をしているか (How)** ではなく、**なぜそうなっているか (Why)** や**意図 (Intent)** を説明するために使います。コードを見ればわかることは書かない。
*   **言い訳コメント:** なぜ一般的な方法と違う実装にしたのか、などの「言い訳」をコメントに残すのは有効です。

### 3.3 エラーハンドリングと例外処理

*   **フレームワーク機構の活用:** フレームワークが提供する例外処理機構（例: Railsの `RecordNotFound`）を適切に活用します。（経験則）
*   **トランザクション管理:** 複数のデータ更新を伴う処理が、適切にトランザクション管理されているか。エラー時にロールバックされるか。

### 3.4 パフォーマンス

*   **データベースアクセス:**
    *   **N+1問題:** ループ内で都度クエリが発行されていないか。`includes`, `preload`, `eager_load` などで一括読み込みされているか。
    *   **不要なデータ取得:** 必要以上のカラムやレコードを取得していないか。`select` や `pluck` を適切に使用しているか。
    *   **DB処理の活用:** 大量データの集計やフィルタリングなど、データベースが得意な処理はアプリケーション側ではなくDB側で行う。
*   **メモリ使用量:** 大量データを扱う際に、全データをメモリにロードせず、バッチ処理（例: `find_each`）などでメモリ効率を考慮しているか。

## 4. テスト (Tests)

### 4.1 テストの目的と種類

*   **適切なテストレベル:** 変更内容に対して、適切な種類のテスト（ユニットテスト、結合テスト、システムテスト/E2Eテスト）がバランス良く書かれているか。
    *   **ユニットテスト:** 個々のクラスやメソッドのロジックを検証する。実行速度が速く、詳細なロジック検証に適している。
    *   **システムテスト:** ユーザー視点での操作と画面遷移を検証する。基本的な動作確認に適している。

### 4.2 テストケースの品質

*   **具体性:** テストケースの説明（`describe`, `context`, `it`）が、テスト対象、条件、期待結果を具体的に示しているか。
*   **安定性:** 実行するたびに結果が変わるような不安定な（flaky）テストになっていないか。
    *   例: `sleep` に依存しない。

### 4.3 テストコードの可読性と保守性

*   **構造化:** テストコードが「準備(Arrange)」「実行(Act)」「検証(Assert)」の構造で分かりやすく書かれているか。
*   **期待値の明確さ:** テストコード単体で期待値の根拠がわかるか。Factoryのデフォルト値などに過度に依存せず、必要に応じて期待値をベタ書きする。
*   **DRY原則のバランス:** テストコードの重複を避けること（`let`, `before`, ヘルパーメソッドなど）と、各テストの独立性・可読性を保つことのバランスが取れているか。
    *   `let`/`let!` の乱用は可読性を下げる場合があるため、`before` やローカル変数の使用も検討する。
*   **不要なテストの排除:** フレームワークやライブラリの標準機能自体をテストするような、冗長なテストは書かない。
*   **デザイン非依存:** システムテストなどで、UIの見た目（CSSクラス名など）に依存しすぎず、`data-testid` 属性などを利用して要素を特定する。

### 4.4 テスト設計

*   **テストデータ:** テストデータの準備方法（FactoryBot, fixtureなど）が適切で、テストの意図を明確にしているか。
    *   FactoryBotの `trait` などを活用して、テストデータ準備の負担を軽減する。

## 5. 開発プロセスとチームワーク (Process & Teamwork)

### 5.1 その他

*   **環境差異の意識:** 開発環境と本番環境の差異を最小限にし、環境依存の不具合を防ぐ。
*   **依存関係管理:** ライブラリ（Gemなど）のバージョン固定は避け、セキュリティアップデートなどを追従できるようにする。

## 6. Ruby on Rails 特有の観点

### 6.1 Model

*   **中間テーブルのモデル命名:** テーブル構造だけでなく、ドメイン上の意味が明確な名前（例: `Subscription`）を付ける。
*   **ユーザーモデルの分離:** 一般ユーザーと管理者は別モデルにする（セキュリティ、保守性向上）。
*   **`default_scope`の回避:** 予期せぬ挙動を避けるため、`default_scope` は使わず明示的な `scope` を使う。
*   **デフォルト値の定義:** `enumerize` の `default` ではなく、Rails標準の `attribute` メソッドを使う（データ整合性のため）。
*   **マイグレーション内のモデル参照禁止:** 将来の失敗を防ぐため、SQLを使うか、データメンテナンスタスクを別途用意する。
*   **DB処理の優先:** 大量データ処理や集計は、Ruby側ではなくDB側で行う（`pluck`, SQL関数など）。
*   **関連データの読み込み:** N+1問題を避けるため、`preload` や `includes` を適切に使う。`has_many`関連では `preload` が推奨される場合が多い。
*   **DB制約の設定:** Railsバリデーションに加え、`NOT NULL`制約やユニークインデックスをDBにも設定し、データ整合性を担保する。
*   **`scope`の戻り値:** `scope` は常に `ActiveRecord::Relation` を返すようにし、メソッドチェーンを可能にする。
*   **現在時刻への依存回避:** モデルが `Time.current` に直接依存せず、引数で時刻を受け取れるようにしてテスト容易性を高める。
*   **`dependent`オプションの吟味:** `dependent: :destroy` などはビジネス要件を考慮し、関連データの削除影響を慎重に検討する。
*   **実行SQLの把握:** ActiveRecordが生成するSQLを確認し、意図通りか（N+1、重複取得などがないか）確認する。`to_sql` やログを活用。
*   **`preload`データの活用:** `preload` した関連データに対して `scope` や `exists?`, `count` を呼ぶとN+1が発生するため、`present?` や `size` を使うか、`scope`付きリレーションを用意する。
*   **トランザクションの利用:** 複数レコード更新時は `transaction` ブロックで囲み、データ整合性を保つ。
*   **大量データ処理:** `each` の代わりに `find_each` を使い、メモリ消費を抑える（ただしid順になる点に注意）。

### 6.2 View

*   **ビューのロジック分離:** 複雑な条件分岐やデータ処理はビューに書かず、ヘルパー、Decorator、Presenter、ViewComponentなどに分離する。
*   **レイアウトファイルの分割:** ユーザー種別などでレイアウトファイルを分割し、ファイル内の条件分岐を減らす。基底コントローラーでレイアウト指定すると良い。
*   **コンポーネントのルート要素:** PartialやViewComponentは、原則として単一のルート要素を持つようにし、外部からのスタイル影響を受けにくくする。
*   **「詳細」リンクの回避:** 「詳細」テキストリンクではなく、タイトルや画像、コンテナ要素自体をクリッカブルにする。
*   **パーシャルのマージン:** 子コンポーネント（パーシャル）のルート要素にはマージンを設定せず、親側で配置時に設定する。
*   **日時フォーマット:** `strftime` ではなく `I18n.l` を使い、表記揺れを防ぎ国際化に対応する。

### 6.3 Controller

*   **RESTfulルーティング:** `resources` を活用し、直感的で分かりやすいルーティングを心がける。複雑な場合はリソースをネストする。
*   **Fat Controller 回避:** データ操作やビジネスロジックはモデル等に委譲し、コントローラーはリクエスト処理とレスポンス準備に専念する。
*   **名前空間と基底コントローラー:** 名前空間ごとに共通処理（`before_action` など）をまとめる基底コントローラー (`Namespace::ApplicationController`) を用意する。
*   **セッション利用の最小化:** CookieStoreのサイズ制限（4KB）を考慮し、セッションには必要最小限のデータのみ保存する。
*   **一覧取得時の`order`:** レコード一覧取得時は、表示順序を保証するため必ず `order` を付ける（必要なら `id` などで一意にする）。
*   **ルーティングと`module`:** ネストしたルーティングでは `module` オプションを使い、URL構造とコントローラーのファイルパス（名前空間）を一致させる。
*   **安全なオブジェクト取得:** `Model.find(params[:id])` ではなく `current_user.association.find(params[:id])` のように、スコープを限定してレコードを取得する。権限管理ライブラリ（Punditなど）やBrakemanの活用も推奨。
*   **`namespace`による権限分離:** 管理者用と一般ユーザー用などで `namespace` を分け、コントローラー内での権限チェック分岐をなくす。
*   **`destroy!`の利用:** 削除失敗時に `false` を返す `destroy` ではなく、例外を発生させる `destroy!` を使い、失敗を確実に検知できるようにする。
*   **単一リソースには`resource`:** マイページなどID不要なリソースには `resources` (複数形) ではなく `resource` (単数形) を使う。

### 6.4 Test

*   **テスト構造化 (`describe`/`context`/`it`):** テスト対象、条件、期待結果を明確に記述する。
*   **具体的なテスト説明:** 抽象的すぎず、どのような条件で成功/失敗するか具体的に書く。
*   **期待値の根拠:** テストコード単体で期待値の根拠がわかるように、必要ならベタ書きする。
*   **デザイン非依存テスト:** テストのためだけにCSSクラスを使わず、`data-testid` 属性などを利用する。
*   **`let`/`let!` vs `before`/ローカル変数:** `let`/`let!` のスコープや遅延評価を考慮し、可読性のため `before` やローカル変数の使用も検討する。
*   **入力値/期待値のベタ書き:** 変数（特に計算結果）を使わずベタ書きすることで、テスト自体のバグによる偽陽性を防ぐ。
*   **Rails標準機能のテスト回避:** ライブラリがテスト済みの標準機能はテストしない。
*   **FactoryBot `trait` の活用:** テストデータ準備の記述量を減らす。
*   **「されないこと」の検証:** `not_to` での検証は、タイポ等で意図せずパスする可能性があるため、逆条件（されること）で失敗することも確認する。
*   **Strong Parameters設定漏れ防止:** `config.action_controller.action_on_unpermitted_parameters = :raise` を設定し、開発中に検知する。
*   **テスト構造化 (準備/実行/検証):** Arrange-Act-Assertパターンで記述し、準備コードは検証コードの近くに置く。
*   **`sleep`の回避:** 非同期処理待機には `sleep` を使わず、Capybaraの待機機能や特定の要素出現を待つ。
*   **不要な値の排除:** テストの検証に直接関係ない値はテストコードに含めない。
*   **効率的なテスト戦略:** System Specで主要フロー、Unit Testで詳細ロジックを分担するなど、テストの種類を適切に使い分ける。

### 6.5 その他

*   **`seed`/スクリプトでのデータ登録:** バリデーション失敗を検知するため `create` ではなく `create!` を使う。
*   **環境差異の意識:** 開発/本番環境の構成を揃え、環境依存設定は環境変数や `credentials` で吸収し、コード上の分岐を避ける。
*   **Gemバージョン固定の回避:** `bundle update` できる状態を保ち、セキュリティアップデート等を追従する。固定が必要な場合は理由をコメントする。
*   **`Enumerable`の活用:** `each` だけでなく `map`, `select`, `reject` など、より適切なメソッドを使いコードを簡潔にする。
*   **YAGNIの遵守:** 将来必要になるかもしれない機能は、実際に必要になるまで実装しない。
*   **命名の重要性:** コードの可読性を左右するため、役割や内容を表す具体的で適切な命名を心がける（クラス、メソッド、変数、DBカラム等）。
*   **単一責務の原則:** メソッドやクラスには一つの役割だけを持たせ、複雑な場合は分割する。
*   **許可リスト > 禁止リスト:** セキュリティ設定（`before_action` の `skip`/`only`/`except` など）では、許可リスト方式 (`only`) を優先し、デフォルトで安全な状態にする。
*   **コメントの役割:** コードの動作説明ではなく、「なぜ」その実装なのかという理由や背景（言い訳）を書く。
*   **「好み」 vs 「良し悪し」:** レビューフィードバックがどちらに基づくものか明確にし、理由を説明する。
