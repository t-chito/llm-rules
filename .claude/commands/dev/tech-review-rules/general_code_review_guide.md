# 一般的なコードレビューガイドライン

## 1. はじめに

### 1.1 コードレビューの目的

コードレビューは、コードとプロダクトの品質を維持・向上させるための重要なプロセスです。主な目的は以下の通りです。

- **コードベースの健全性の維持・向上:** 時間をかけてコードベース全体の品質を高めます。
- **バグの早期発見:** 実装段階での誤りや潜在的な問題点を特定します。
- **知識共有と学習:** チームメンバー間での知識共有を促進し、開発者のスキルアップを図ります。
- **コードの一貫性確保:** プロジェクト全体のコーディングスタイルや設計原則の一貫性を保ちます。
- **保守性と可読性の向上:** 将来の変更やデバッグを容易にする、理解しやすいコードを作成します。

### 1.2 コードレビューの基本原則

- **継続的な改善を重視する:** 完璧さではなく、コードベース全体の健全性を**継続的に改善**することを目指します。CL（Change List / プルリクエスト）がシステム全体の健全性を向上させるなら、積極的に承認します。逆に、健全性を悪化させる CL は、緊急時を除き承認すべきではありません。（Google）
- **コミュニケーションを重視する:** コードは他の開発者や将来の自分自身へのコミュニケーション手段です。明確で理解しやすいコードを書くことが重要です。（Code Complete, プリンシプルオブプログラミング）
- **敬意を持って行う:** コメントは**コード**に対して行い、**開発者本人**を批判しないようにします。丁寧な言葉遣いを心がけ、提案の「なぜ」を説明します。（Google）
- **迅速な応答:** レビュー依頼には可能な限り早く（目安として 1 営業日以内）応答します。ただし、集中作業中は中断せず、適切なタイミングで行います。（Google）
- **「好み」と「良し悪し」を区別する:** フィードバックが客観的な改善提案（良し悪し）なのか、主観的な好みなのかを明確にし、理由を説明します。

## 2. 設計 (Design)

### 2.1 責務と凝集度・結合度

- **単一責任の原則 (SRP):** クラスやメソッドは、一つの明確な責務（役割）を持つべきです。複数の無関係な処理を一つの単位で行わないようにします。（Code Complete）
  - 例: `UserManagerAndReportGenerator` のようなクラスは責務が多すぎる可能性が高い。
- **高凝集・疎結合:** 関連性の高いコードは近くにまとめ（高凝集）、モジュール間の依存関係は最小限に抑えます（疎結合）。変更が他の部分へ与える影響を少なくします。（経験則, Code Complete）
- **適切なクラス設計:** 不要なバリューオブジェクトや過度な汎用化（YAGNI 違反）を避け、シンプルで目的に合ったクラス設計を行います。（経験則）
- **ロジックの適切な配置:** ビジネスロジックやデータ操作ロジックが、適切なクラスに配置されているか確認します。（経験則）
- **継承より委譲を好む:** コードの再利用や拡張性を高めるため、安易な継承よりも委譲（composition）を優先的に検討します。継承はクラス間の強い結合を生みやすく、将来的な変更に弱くなるため、まずは委譲で実現できないかを考えます。（Code Complete, プリンシプルオブプログラミング）
- **結果の局所化:** 変更の影響範囲が限定的になるように、関連性の高いコードがまとめられているか。（プリンシプルオブプログラミング）
- **ロジックとデータの一体化:** データとそのデータを操作するロジックが、同じクラスやモジュール内に適切に配置されているか。（プリンシプルオブプログラミング）
- **関心の分離 (SoC):** 異なる関心事（例: UI、ビジネスロジック、データアクセス）が適切に分離され、それぞれのモジュールが独立して変更・理解できるようになっているか。（プリンシプルオブプログラミング）
- **インターフェースと実装の分離:** 具象クラスに直接依存するのではなく、インターフェースや抽象クラス（あるいはダックタイピング）を通じて依存することで、実装の変更が容易になっているか。（プリンシプルオブプログラミング）
- **再利用性:** モジュール化、コンポーネント化、設定可能性などを通じて、コードが他のコンテキストでも再利用しやすいように設計されているか。（プリンシプルオブプログラミング）

### 2.2 変更容易性と柔軟性

- **変更の予測と隔離:** 将来変更される可能性が高い箇所（外部 API 連携、ビジネスルールなど）を特定し、変更が容易になるように設計します。（Code Complete）
- **オープン/クローズドの原則 (OCP):** ソフトウェアエンティティ（クラス、モジュール、関数など）は、拡張に対して開いており、修正に対して閉じているべきです。既存のコードを変更せずに機能追加ができるか。（プリンシプルオブプログラミング）

### 2.3 シンプルさと YAGNI

- **シンプルさ (KISS):** 必要以上に複雑なコードになっていないか確認します。「複雑」とは、すぐに理解できない、または変更時にバグを生みやすいコードを指します。（Google, Code Complete, プリンシプルオブプログラミング）
- **YAGNI (You Ain't Gonna Need It):** 現時点で必要ない機能や汎用化（オーバーエンジニアリング）は実装しません。将来の問題は、実際に発生してから対処します。（Google, プリンシプルオブプログラミング）
- **標準的な方法の利用:** より単純で標準的な方法（例: HTML 標準タグ vs JS）で実装できないか検討します。（経験則）

### 2.4 API 設計とインターフェース

- **RESTful な設計:** Web API などは、リソース指向に基づいた RESTful な設計原則に従っているか確認します。URL 設計（パス）、HTTP メソッドの選択が適切か。（経験則）
- **インターフェースの一貫性:** 関連する API やメソッド間で、インターフェース（パラメータ、レスポンス形式など）に一貫性があるか確認します。（経験則）
- **パラメータ設計:** API 等のパラメータが必要十分か。不要なパラメータや、クライアントから送るべきでない情報（例: 内部 ID）が含まれていないか。（経験則）
- **相互運用性:** 標準的なプロトコルやデータ形式（例: JSON, REST）を採用するなど、他のシステムと連携しやすい設計になっているか。（プリンシプルオブプログラミング）

### 2.5 抽象化

- **適切な抽象化レベル (SLAP):** 同じルーチンやコードブロック内で、抽象レベルが混在していないか確認します。高レベルな処理と低レベルな実装詳細が混在している場合は、ルーチン抽出などでレベルを揃えます。（プリンシプルオブプログラミング, Code Complete）
  - 例: `processOrder()` 内でビジネスロジックのステップと低レベル DB アクセスコードが混在している場合、DB アクセスは別メソッドに抽出する。
- **重複ロジックの抽象化:** ロジックが重複している場合は、適切なクラスやメソッドに抽出して共通化します。（経験則, Code Complete）
- **充足性、完全性、プリミティブ性:** 抽象化のレベルや粒度が適切か。提供されるインターフェースが必要十分（充足性）で、期待される機能を網羅（完全性）し、基本的な操作で構成（プリミティブ性）されているか。（プリンシプルオブプログラミング）

### 2.6 フレームワーク・ライブラリの利用

- **フレームワーク機能の活用:** フレームワークが提供する機能を適切に活用し、コードをシンプルに保てているか確認します。（経験則）
- **依存関係の吟味:** 新たなライブラリを追加する場合、その必要性やメリットが十分か検討します。不要な依存は避けます。（経験則）
- **車輪の再発明の回避:** 標準ライブラリ、フレームワーク、または信頼できる既存のライブラリで実現できる機能を、独自に実装していないか。（プリンシプルオブプログラミング）

### 2.7 設計レビューを**必ず**行う必要がある場合

- 一度行うと簡単には変更できないような設計に関するプルリクエストにはシニアエンジニア以上の設計レビューを**必ず**行う必要がある
- 外部プロダクトとの連携が行われる場合はそのプロダクト担当者を交えた設計レビューを**必ず**行う必要がある
- データベースへの追加や変更はシニアエンジニア以上の設計レビューを**必ず**行う必要がある
- モデルに関するクラスを新規で作成する場合はシニアエンジニア以上の設計レビューを**必ず**行う必要がある

## 3. コード品質 (Code Quality)

### 3.1 可読性・理解可能性

- **明確さと意図:** コードが読みやすく、開発者の意図が明確に伝わるか確認します。初見の開発者でも理解できるか。（Google, Code Complete, 経験則）
- **コードの差分の見やすさ:** 変更差分（diff）が追いやすいように、適切な粒度（例: 1 行 1 要素）でコードが記述されているか。（経験則）
- **構造化プログラミング:** 制御フロー（if, while, case など）が単純で理解しやすいか。深いネストは避けます。（Code Complete）
  - **ネスト削減:** ガード節、早期リターン、メソッド抽出、ポリモーフィズムなどでネストを浅くする。（Code Complete）
- **論理的な順序とグループ化:** ステートメントが論理的な順序で記述され、関連するコードが空白行などで適切にグループ化されているか。（Code Complete）
- **コードは設計書:** コード自体が、将来のメンテナーにとって最も信頼できる設計ドキュメントであるという意識で書かれているか。コードから設計意図が読み取れるか。（プリンシプルオブプログラミング）
- **線形原理:** 処理の流れが複雑に分岐したりジャンプしたりせず、上から下へ自然に読み進められるか。状態遷移が複雑すぎないか。（プリンシプルオブプログラミング）
- **明証原理:** コードが一見して正しいと理解でき、ロジックが自明であるか。複雑な部分はコメントやドキュメントで補足されているか。（プリンシプルオブプログラミング）

### 3.2 命名 (Naming)

- **明確で具体的な名前:** 変数、メソッド、クラス、定数などの名前が、その役割や内容を正確かつ明確に伝えているか。曖昧な名前（`data`, `temp`, `flag`など）は避けます。（Google, Code Complete, プリンシプルオブプログラミング, 経験則）
- **一貫性:** プロジェクト内で命名規則（キャメルケース、スネークケースなど）や用語が一貫しているか。（経験則, Code Complete）
- **規約への準拠:** 言語やフレームワークの命名規約に従っているか。
- **副作用の明示:** 副作用のあるメソッドには動詞を、ないメソッドには名詞を使うなど、メソッドの性質を名前に反映させる。
- **効果と目的:** 名前が、その要素が何をするか（効果）だけでなく、なぜそれをするのか（目的）も伝えているか。（プリンシプルオブプログラミング）
- **発音可能・検索可能:** チームメンバーが口頭で議論しやすく、コードベース内で検索しやすい名前になっているか。（プリンシプルオブプログラミング）
- **驚き最小の原則:** 名前から期待される動作と、実際の動作が一致しているか。誤解を招く名前になっていないか。（プリンシプルオブプログラミング）

### 3.3 コードの重複回避 (DRY - Don't Repeat Yourself)

- **ロジックの重複:** 同じ、または類似したコードが複数の場所に存在しないか確認します。共通化（メソッド抽出、クラス作成、ヘルパー利用など）を検討します。（Code Complete, プリンシプルオブプログラミング, 経験則）
- **設定や定数の重複:** 設定値や定数が複数の場所で定義されていないか。一元管理されているか。（経験則）

### 3.4 複雑性 (Complexity)

- **コードの単純さ:** 必要以上に複雑なロジックや制御フローになっていないか。よりシンプルに書けないか検討します。（Google）
- **早期最適化の回避:** パフォーマンスチューニングは、計測に基づいて必要な箇所にのみ行います。可読性や保守性を犠牲にする早期最適化は避けます。（Code Complete, 経験則）

### 3.5 マジックナンバー/文字列の回避

- **定数化:** コード中に直接記述された数値や文字列（マジックナンバー、マジックストリング）に意味がある場合、意味のある名前を持つ定数として定義します。（経験則, Code Complete）
  - 例: `if status == 1` ではなく `if status == STATUS_PUBLISHED` のようにする。

### 3.6 不要なコードの削除

- **未使用コード:** 使用されていない変数、メソッド、クラス、ファイル、設定、インポートなどがないか確認します。（経験則）
- **デッドコード:** 到達不能なコードや、実行されても意味のないコードがないか確認します。
- **コメントアウトされたコード:** 不要になったコードはコメントアウトせず、バージョン管理システムを信頼して削除します。

### 3.7 コメント (Comments)

- **「なぜ」を説明する:** コメントは、コードが**何をしているか (How)** ではなく、**なぜそうなっているか (Why)** や**意図 (Intent)** を説明するために使います。コードを見ればわかることは書かない。（Google, Code Complete）
- **有益なコメント:** 複雑なアルゴリズム、正規表現、ワークアラウンド、設計上の決定事項など、コードだけでは理解が難しい点を補足します。（Google, Code Complete）
- **正確性と最新性:** コメントの内容がコードと一致しており、最新の状態に保たれているか確認します。コード変更時にコメントも更新します。（Code Complete）
- **自己文書化コード:** コード自体を分かりやすく書くことで、コメントの必要性を減らすことを目指します。（Code Complete）
- **マーカーコメント:** `TODO`, `FIXME` などのマーカーは、チームの規約に従って使用し、適切に管理（タスク化など）します。（Code Complete）
- **言い訳コメント:** なぜ一般的な方法と違う実装にしたのか、などの「言い訳」をコメントに残すのは有効です。

### 3.8 スタイルとフォーマット (Style)

- **スタイルガイド準拠:** プロジェクトや言語コミュニティで定められたスタイルガイドに従っているか確認します。（Google, Code Complete）
- **一貫性:** プロジェクト全体でコーディングスタイル（インデント、スペース、括弧の位置など）が一貫しているか確認します。（Code Complete）
- **視覚的構造:** インデントや空白行が、コードの論理構造を視覚的に分かりやすく表現しているか。（Code Complete）
- **Nitpick（細かい指摘）:** スタイルガイドにない純粋なスタイルの好みに関する指摘は、修正を強制せず、「Nit:」などのプレフィックスを付けて提案します。（Google）
- **同型原理:** 同じ種類の処理やデータ構造は、一貫したパターンや形式で記述されているか。不必要な例外や特殊ケースが導入されていないか。（プリンシプルオブプログラミング）
- **対称原理:** 対になる操作（例: `open`/`close`, `lock`/`unlock`, `create`/`destroy`）が考慮され、整合性が保たれているか。条件分岐などで、対になるケースが適切に扱われているか。（プリンシプルオブプログラミング）

### 3.9 エラーハンドリングと例外処理

- **予期せぬ入力への対応:** ユーザー入力や外部データなど、予期せぬ値（nil, 空文字, 不正フォーマットなど）に対する考慮がされているか。（経験則）
  - 例: ユーザー入力起因で `ArgumentError` などが発生しないようにする。（経験則）
- **適切な例外処理:** 例外を単なる制御フローとして使わず（例: ループ脱出など）、真に例外的な状況で使用します。（経験則, Code Complete）
- **エラー情報の記録:** エラー発生時に、原因究明に必要な情報（パラメータ、コンテキストなど）がログやエラー監視ツールに記録されるか。（経験則）
- **リソース解放:** ファイルハンドル、ネットワーク接続、ロックなどのリソースが、エラー発生時も含めて確実に解放されるか (`try-finally`, `ensure` など）。（Code Complete）
- **トランザクション管理:** 複数のデータ更新を伴う処理が、適切にトランザクション管理されているか。エラー時にロールバックされるか。（経験則）
- **信頼性 (ロバストネス):** 予期せぬ入力、不正な操作、外部システムの異常などに対して、システムがクラッシュしたり、不正な状態になったりしないように防御されているか。（プリンシプルオブプログラミング）

### 3.10 防御的プログラミング

- **アサーション:** 開発中に、コードが特定の前提条件を満たしていることを表明・検証するためにアサーションを使用します。（Code Complete）
- **入力値検証:** ルーチンやメソッドの境界で、受け取ったパラメータが期待される範囲や型であるか検証します。（Code Complete）
- **エラー処理戦略:** エラー発生時にプログラムを安全に停止させるか、エラーを通知して処理を継続するかなど、一貫したエラー処理戦略があるか。（Code Complete）
- **安全原理:** 「ありえない」と思われるようなエッジケースや潜在的なエラー条件も考慮に入れ、システムが安全に動作するように設計・実装されているか。（プリンシプルオブプログラミング）

### 3.11 データ型と構造

- **適切なデータ型:** 変数やデータベースカラムに、格納するデータに適した型（数値、文字列、真偽値、日付、enum など）が選択されているか。（経験則）
  - 例: 金額には適切な数値型を使うべきか検討する。（経験則）
- **Boolean 型の扱い:** 真偽値の扱いが適切か（例: `true`/`false` vs `1`/`0` vs 文字列）。（経験則）
- **Enum の適切な利用:** Enum の値設定（例: 1, 2, 3 vs 10, 20, 30）やバリデーションが適切か。（経験則）
- **データ構造:** 複雑なデータを扱う際に、クラス、構造体、ハッシュなどが適切に利用されているか。

### 3.12 パフォーマンス

- **効率的なアルゴリズムとデータ構造:** 処理内容に対して、効率的なアルゴリズムやデータ構造が選択されているか。
- **データベースアクセス:**
  - **N+1 問題:** ループ内で都度クエリが発行されていないか。一括読み込みの仕組みが活用されているか。
  - **不要なデータ取得:** 必要以上のカラムやレコードを取得していないか。必要なデータのみを取得する方法が活用されているか。
  - **DB 処理の活用:** 大量データの集計やフィルタリングなど、データベースが得意な処理はアプリケーション側ではなく DB 側で行う。
  - **インデックス:** 頻繁に検索条件となるカラムにインデックスが適切に設定されているか。
- **メモリ使用量:** 大量データを扱う際に、全データをメモリにロードせず、バッチ処理などでメモリ効率を考慮しているか。
- **信頼性 (フェールとトレランス):** 特定のコンポーネントで障害が発生した場合でも、システム全体が停止せず、可能な限り動作を継続できるような仕組み（冗長化、フォールバック、自動再試行など）が考慮されているか。（プリンシプルオブプログラミング）

## 4. テスト (Tests)

### 3.13 不変性 (Immutability)

- **参照の一点性 (単一代入):** 変数やオブジェクトの状態が、初期化後に変更されない（イミュータブルである）ように努めているか。意図しない状態変更を防げているか。（プリンシプルオブプログラミング）
- **参照透明性:** 関数の実行が外部の状態に影響を与えず（副作用がない）、同じ入力に対して常に同じ結果を返すようになっているか。これにより、コードの予測可能性とテスト容易性が向上する。（プリンシプルオブプログラミング）

## 4. テスト (Tests)

### 4.1 テストの目的と種類

- **適切なテストレベル:** 変更内容に対して、適切な種類のテスト（ユニットテスト、結合テスト、システムテスト/E2E テスト）がバランス良く書かれているか。（Google）
  - **ユニットテスト:** 個々のクラスやメソッドのロジックを検証する。実行速度が速く、詳細なロジック検証に適している。
  - **システムテスト:** ユーザー視点での操作と画面遷移を検証する。基本的な動作確認に適している。
- **テスト容易性:** コードがテストしやすいように設計されているか（依存関係の注入、副作用の分離など）。（経験則, Code Complete）

### 4.2 テストケースの品質

- **網羅性:** 正常系、異常系、境界値など、考慮すべきケースが適切にテストされているか。（経験則）
- **具体性:** テストケースの説明が、テスト対象、条件、期待結果を具体的に示しているか。
- **独立性:** テストケースが他のテストケースに依存せず、単独で実行可能か。実行順序に依存していないか。
- **安定性:** 実行するたびに結果が変わるような不安定な（flaky）テストになっていないか。（経験則）
- **正確なアサーション:** 検証内容に対して、適切で明確なアサーションが使われているか。（経験則）
  - 例: 文字列比較では完全一致ではなく部分一致や正規表現を使うべきか検討する。

### 4.3 テストコードの可読性と保守性

- **構造化:** テストコードが「準備(Arrange)」「実行(Act)」「検証(Assert)」の構造で分かりやすく書かれているか。
- **期待値の明確さ:** テストコード単体で期待値の根拠がわかるか。デフォルト値などに過度に依存せず、必要に応じて期待値をベタ書きする。
- **DRY 原則のバランス:** テストコードの重複を避けることと、各テストの独立性・可読性を保つことのバランスが取れているか。
- **不要なテストの排除:** フレームワークやライブラリの標準機能自体をテストするような、冗長なテストは書かない。
- **デザイン非依存:** システムテストなどで、UI の見た目（CSS クラス名など）に依存しすぎず、テスト用の属性などを利用して要素を特定する。

### 4.4 テスト設計

- **モック/スタブの適切な利用:** 外部依存（API、DB など）を切り離すために、モックやスタブが適切に使用されているか。過度なモックはテストを脆くする可能性もあるため注意。（経験則）
- **テストデータ:** テストデータの準備方法が適切で、テストの意図を明確にしているか。

## 5. ドキュメンテーション (Documentation)

- **コードの意図の明確化:** コードだけでは理解が難しいロジックや設計判断について、コメントで意図が補足されているか。（Code Complete, 経験則）
- **関連ドキュメントの更新:** コード変更に伴い、関連するドキュメント（README, API 仕様書, 設計書など）も更新されているか。（Google）
- **ドキュメンテーションの必要性:** 必要なドキュメンテーションが存在しない場合、作成を依頼する。（Google）

## 6. 開発プロセスとチームワーク (Process & Teamwork)

### 6.1 レビュープロセス

- **レビューのスピード:** 迅速なフィードバックを心がける。（Google）
- **丁寧なレビュー:** コードを一行ずつ注意深く読み、必要に応じて動作検証も行う。（Google）
- **コンテキストの確認:** 変更箇所だけでなく、ファイル全体やシステム全体への影響も考慮する。（Google）
- **大きな変更への対応:** レビューが困難なほど大きな変更は、可能であれば分割を依頼する。分割できない場合でも、まずは全体設計に関するフィードバックを返す。（Google）

### 6.2 コミュニケーション

- **丁寧さと建設性:** 敬意を持った言葉遣いをし、開発者の成長を促すようなフィードバックを心がける。（Google）
- **明確な指示:** 問題点を指摘するだけでなく、具体的な改善案や方向性を示す。（Google）
- **称賛:** 良いコードや改善が見られた場合は、積極的に称賛する。（Google）
- **意見の対立解消:** 意見が対立した場合は、まず相手の主張を理解しようと努める。解決しない場合は、対面での議論や第三者（TL、マネージャーなど）の介入を検討する。放置しない。（Google）

### 6.3 標準と規約

- **チーム規約の遵守:** プロジェクトやチームで定められたコーディング規約、設計標準、開発プロセスに従っているか。（経験則, Code Complete）
- **社内規約の遵守:** 組織全体の規約やガイドラインがあれば、それに準拠しているか。（経験則）

### 6.4 その他

- **「あとで修正する」の扱い:** 緊急時を除き、「あとで修正する」は原則として認めず、その場で修正するか、具体的なタスク（TODO コメント、チケット起票）として管理する。（Google）
- **環境差異の意識:** 開発環境と本番環境の差異を最小限にし、環境依存の不具合を防ぐ。
- **依存関係管理:** ライブラリのバージョン固定は避け、セキュリティアップデートなどを追従できるようにする。
