---
description: unit testing and regression protection for software
---

# test command

## 基本方針

テストの目的は、ソフトウェアに対して退行に対する保護とリファクタリングへの耐性を与え、安心してコードを変更し続けられるようにすることです。そのため、テストは Specification by Example の役割を果たし、仕様を表現します。

ただし、コードは負債です。テストコードも例外ではありません。コードの量がそのまま負債の量となるのと同様、テストコードも量より質を重視する必要があります。目的への貢献度合いと記述量のトレードオフを意識し、質の高いテストスイートを維持するように努める必要があります。

## 実装手順（ペアプロ形式）

このプロンプトはペアプロ形式を前提とします：
**なぜペアプロ形式か：** 段階的な品質確保、ユーザーとの認識合わせ、手戻りの防止を図るため

- 各ステップで具体的なアウトプットを作成し、ユーザーの確認・承認を得てから次に進む
- ユーザーの指示なしに勝手に先に進まない
- 疑問や判断に迷う場合は必ずユーザーに確認する

**各ステップ共通の DoD：**

- [ ] 対応するファイルが生成または更新されている
- [ ] ユーザーのレビューを通り、明示的に次へ進んで良いという指示を受け取った

### Step 1: 要件理解とテスト計画立案

**なぜこのステップか：** 実装の詳細に依存せず、要求・要件ベースでテスト対象を決めるため

**成果物：** テスト計画ファイル（Markdown 等）

**やること：**

- 要件を理解する
- テスト計画を立案する
  - テスト対象となる機能/振る舞いの一覧
  - 各対象で検証すべき観点（正常系、エラー系、境界値、特殊ケース）
  - 想定されるテストケース数と概要

**判断基準：** ドメイン（業務）における重要性が高い処理ほどテストする価値が高い

- ビジネスロジックや計算処理
- バグが致命的な影響を及ぼす箇所
- 複雑で壊れやすい箇所

逆に、UI の文言表示や単純なラッパー関数など、ドメイン知識とあまり関係のない箇所はテストの優先度を下げても問題ありません。

### Step 2: テストケース設計

**なぜこのステップか：** 実装の詳細に依存しないテスト構造と期待する結果を確定するため

**成果物：** テストファイル（スケルトン）

**前提となる考え方：**

- 古典学派（デトロイト派）の単体テストの定義に従いつつ、SpecBDD や Specification by Example の考えも一部採用する
- 実装の詳細ではなく 1 単位の振る舞い（機能）を検証する
- テストケースに仕様の役割を持たせる
- 「ある条件下で〜するとき、〜という結果になること」のような形式で記述する
- 外部依存がない限り、基本的にはモックは使わない
- Arrange, Act, Assert パターンに従う

**やること：**

- テストケースのスケルトンを作成
- この時点でテスト構成と期待する結果を確定し、以降は変更しない

### Step 3: 各 describe ブロックの最初のテストケース実装

**なぜこのステップか：** arrange/act/assert のどこに問題があるかを切り分けるため

**成果物：** 部分実装されたテストファイル

**やること：**

- 各 describe ブロックごとに 1 つのテストケースを実装・実行
- テストがパスすることを確認
- 基本的なテスト構造を確立

**実装時の注意事項：**

- **期待値はベタ書き**する
- **計算ロジックをテスト側で複製しない**
- **1 つのテストケースで 1 つの事柄だけを検証**する
- テストコード内に条件分岐を作らない
- 振る舞い（出力や結果）を検証し、実装の詳細に依存しない
- **重要：実装側のコードには一切手を加えない**

### Step 4: 残りのテストケース実装

**なぜこのステップか：** 基本構造が確立された後、効率的に全テストケースを完成させるため

**成果物：** 完成したテストファイル

**やること：**

- 各 describe ブロック内の残りのテストケースを実装
- 共通化を意識しながら進める
- 全テストケースの実行と確認

**トラブルシューティング：**
何度テストコードを修正してもテストがパスしない場合は、ユーザーに状況を報告し判断を仰ぐ。

## DoD（Definition of Done）

### テストそのものへの要求から

- [ ] 全てのテストが実装され、かつパスしていること
- [ ] テストケースのタイトル、内部のコメント、実装内容、期待値が矛盾なく整合していること
- [ ] テストコードの記述が機能の振る舞いのみに着目しており、実装の詳細に依存した記述が存在しないこと
- [ ] 外部依存がない限り、モックを使用していないこと

### テストの保守性の観点から

- [ ] Arrange, Act, Assert パターンに従っていること
- [ ] テストの構造を自然言語で追試できるだけのコメントが記されていること
- [ ] Act, Assert がシンプルなロジックとなっており、 Arrange も可能な限り共通化、簡素化されていること

## サンプル

./samples には、アウトプットのイメージを掴むためのサンプルファイルを用意しています。

- [test_plan.md](./samples/test_plan.md): 商品割引計算システムのテスト計画
- [test_spec_skeleton.md](./samples/test_spec_skeleton.md): 「複数割引の組み合わせ制限」機能の RSpec スケルトン

### test_plan.md

- step1 のサンプルです。
- 例として、商品割引計算システム全体を 6 つの主要機能に分割し、各機能の検証観点と想定テストケース数を整理しました。
- 実装優先度とともに総計 42 件のテストケースを示しています。

### test_spec_skeleton.md

- step2 のサンプルです。
- 商品割引計算システムのうち、最も複雑な「複数割引の組み合わせ制限」機能に対する 12 件の specify を含む RSpec のスケルトンを提供しています。
- context による階層化と具体的な検証内容をコメントで示し、実装の詳細に依存しないテストケースを設計しています。
